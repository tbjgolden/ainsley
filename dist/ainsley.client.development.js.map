{"version":3,"file":"ainsley.client.development.js","sources":["../src/utils/index.ts","../src/generate/index.ts","../src/embed/index.ts"],"sourcesContent":["export const isObject = (val: unknown): boolean =>\n  !!(val !== null && typeof val === 'object' && !Array.isArray(val))\n\nexport const combinations = <T>(mods: T[][]): T[][] => {\n  let list: T[][] = [[]]\n  let index = 0\n  while (index < mods.length) {\n    list = mods[index++].flatMap((option) =>\n      list.map((prev) => prev.concat([option]))\n    )\n  }\n  return list\n}\n","import {\n  Ainsley,\n  AinsleyRule,\n  AinsleyPropertyOrPlaceholder,\n  AinsleyVariableMap,\n  AinsleyChild,\n  AinsleyChildren,\n  AinsleyGenerateOptions\n} from '../types'\nimport { combinations } from '../utils'\n\ninterface AinsleyASTNode {\n  $variations: Array<[string, string]>\n  $content: string | AinsleyRule\n}\ntype AinsleyAST = AinsleyASTNode[]\n\nexport const ITERATOR_REGEX = '\\\\{[a-zA-Z0-9_-]+\\\\}'\nexport const DEFAULT_OPTIONS: AinsleyGenerateOptions = {\n  addVariationToSelector: (selector, variationAbbreviation) =>\n    variationAbbreviation + '_' + selector,\n  addPropertyToSelector: (selector, propertyAbbreviation) =>\n    selector + '-' + propertyAbbreviation,\n  addValueToSelector: (selector, valueAbbreviation) =>\n    selector + '-' + valueAbbreviation,\n  abbreviateProperty: (propertyName) => [\n    propertyName\n      .split('-')\n      .map((word) => word[0])\n      .join(''),\n    propertyName\n  ]\n}\n\nconst ITERATOR_SEARCH = new RegExp(ITERATOR_REGEX, 'g')\n\nexport const generate = (\n  ainsley: Ainsley,\n  options: Partial<AinsleyGenerateOptions> = {}\n): string => {\n  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }\n  return generateFromAst(\n    ainsleyToAst(ainsley, mergedOptions, {}),\n    mergedOptions\n  )\n}\n\n// next step:\n// get variations to append to nested variations by passing them down;\n// kinda like variables. this allows us to merge nested variations in the output\n// which is kinda fun. but mostly because I don't know another way to do it\n\n// next next step:\n// get combinations to return a read only array - avoiding the need to\n// recursively clone and concat - also means comparisons for this flattening\n// business is made much simpler\n\nconst generateFromAst = (\n  ainsleyRules: AinsleyAST,\n  options: AinsleyGenerateOptions\n): string => {\n  let css = ''\n  let lastVariations: Array<[string, string]> = []\n  for (let i = 0; i < ainsleyRules.length; i++) {\n    const ainsleyRule = ainsleyRules[i]\n\n    let firstChange = 0\n    while (\n      firstChange < lastVariations.length &&\n      lastVariations[firstChange] === ainsleyRule.$variations[firstChange]\n    ) {\n      firstChange += 1\n    }\n\n    const variationsToClose = lastVariations.slice(firstChange)\n    for (const variationToClose of variationsToClose) {\n      const variationInstruction = variationToClose[1]\n      if (variationInstruction.startsWith('@')) css += '}'\n    }\n    const variationsToOpen = ainsleyRule.$variations.slice(firstChange)\n    for (const variationToOpen of variationsToOpen) {\n      const variationInstruction = variationToOpen[1]\n      if (variationInstruction.startsWith('@'))\n        css += `${variationInstruction}{`\n    }\n\n    if (typeof ainsleyRule.$content === 'string') {\n      css += ainsleyRule.$content\n    } else {\n      let selector = ainsleyRule.$content[0]\n      let selectorSuffix = ''\n\n      for (let i = 0; i < ainsleyRule.$variations.length; i++) {\n        const variationAbbreviation = ainsleyRule.$variations[i][0]\n        const variationInstruction = ainsleyRule.$variations[i][1]\n        if (variationInstruction === '') continue\n        if (!variationInstruction.startsWith('@')) {\n          selectorSuffix += `${variationInstruction}`\n        }\n        selector = options.addVariationToSelector(\n          selector,\n          variationAbbreviation\n        )\n      }\n      css += `.${selector}${selectorSuffix}{${ainsleyRule.$content[1]\n        .map((declaration) => `${declaration[0]}:${declaration[1]}`)\n        .join(';')}}`\n    }\n    lastVariations = ainsleyRule.$variations\n  }\n  for (const variationToClose of lastVariations) {\n    const variationInstruction = variationToClose[1]\n    if (variationInstruction.startsWith('@')) css += '}'\n  }\n  return css\n}\n\nconst ainsleyToAst = (\n  ainsley: Ainsley,\n  options: AinsleyGenerateOptions,\n  inheritedVariables: AinsleyVariableMap\n): AinsleyAST => {\n  // first, compute variables\n  const newVariables = { ...inheritedVariables }\n  if (ainsley.variables !== undefined) {\n    const variables = ainsley.variables\n    Object.keys(variables).map((variable: string) => {\n      const modAndBase = parseVariable(variable)\n      const mod = modAndBase[0]\n      const base = modAndBase[1]\n      if (mod === 0 || (mod === 1 && newVariables[base] === undefined)) {\n        newVariables[base] = variables[variable]\n      } else if (mod === 2) {\n        newVariables[base] = {\n          ...(inheritedVariables[base] ?? {}),\n          ...variables[variable]\n        }\n      }\n    })\n  }\n\n  // then, flatten children into ast\n  const rulesListWithoutVariations =\n    ainsley.children === undefined\n      ? []\n      : ainsleyChildrenToAst(ainsley.children, options, newVariables)\n\n  // lastly, multiply ast with variations\n  const rulesList = combinations(\n    (ainsley.variations ?? []).map((variationSet) =>\n      [['', ''] as [string, string]].concat(variationSet)\n    )\n  ).flatMap((variations) =>\n    rulesListWithoutVariations.map((ainsleyASTNode) => ({\n      $variations: [...variations, ...ainsleyASTNode.$variations],\n      $content: ainsleyASTNode.$content\n    }))\n  )\n\n  return rulesList\n}\n\nconst ainsleyChildrenToAst = (\n  ainsleyChildren: AinsleyChildren,\n  options: AinsleyGenerateOptions,\n  variables: AinsleyVariableMap\n): AinsleyAST =>\n  ainsleyChildren.flatMap((child: AinsleyChild) => {\n    if (typeof child === 'string') {\n      return [\n        {\n          $variations: [],\n          $content: child\n        }\n      ]\n    } else if (Array.isArray(child)) {\n      if (Array.isArray(child[1])) {\n        return ainsleyRuleToAst(child as AinsleyRule, options, variables)\n      } else {\n        return ainsleyPropertyToAst(\n          child as AinsleyPropertyOrPlaceholder,\n          options\n        )\n      }\n    } else {\n      return ainsleyToAst(child, options, variables)\n    }\n  })\n\ntype AinsleyGenerateIteratorContext = [string, string, string | number, number]\n\nconst ainsleyRuleToAst = (\n  ainsleyRule: AinsleyRule,\n  options: AinsleyGenerateOptions,\n  variables: AinsleyVariableMap\n): AinsleyAST => {\n  const selector = ainsleyRule[0]\n  const declarations = ainsleyRule[1]\n  const variablesFound: Array<[string, number]> = []\n  declarations.map((declaration) => {\n    const propertyMatches = declaration[0].match(ITERATOR_SEARCH) ?? []\n    const valueMatches = `${declaration[1]}`.match(ITERATOR_SEARCH) ?? []\n    propertyMatches.map((match) => variablesFound.push([match, 0]))\n    valueMatches.map((match) => variablesFound.push([match, 1]))\n  })\n\n  return combinations(\n    variablesFound.map((iteratorAndType: [string, number]) => {\n      const iterator = iteratorAndType[0]\n      const location = iteratorAndType[1]\n      const variableName = iterator.slice(1, -1)\n\n      return Object.keys(variables[variableName]).map(\n        (abbreviation: string): AinsleyGenerateIteratorContext => [\n          iterator,\n          abbreviation,\n          variables[variableName][abbreviation],\n          location\n        ]\n      )\n    })\n  ).map((combination) => {\n    let combinationIndex = 0\n    let current: AinsleyGenerateIteratorContext = combination[combinationIndex]\n\n    return {\n      $variations: [],\n      $content: [\n        combination.reduce(\n          (selector: string, part: AinsleyGenerateIteratorContext) => {\n            if (part[3] === 0) {\n              return options.addPropertyToSelector(selector, part[1])\n            } /* if (part[3] === 1) */ else {\n              return options.addValueToSelector(selector, part[1])\n            }\n          },\n          selector\n        ),\n        declarations.map((declaration) => {\n          const replacePart = (declarationPart: string): string => {\n            while (\n              combinationIndex < combination.length &&\n              declarationPart.includes(current[0])\n            ) {\n              declarationPart = declarationPart.replace(\n                current[0],\n                `${current[2]}`\n              )\n              current = combination[++combinationIndex]\n            }\n            return declarationPart\n          }\n          return [replacePart(declaration[0]), replacePart(`${declaration[1]}`)]\n        })\n      ]\n    }\n  })\n}\n\nconst ainsleyPropertyToAst = (\n  ainsleyProperty: AinsleyPropertyOrPlaceholder,\n  options: AinsleyGenerateOptions\n): AinsleyAST => {\n  const propertyInput = ainsleyProperty[0]\n  const propertyValues = ainsleyProperty[1]\n\n  const propertyData: [string, string] = options.abbreviateProperty(\n    propertyInput\n  )\n  const propertyAbbreviation = propertyData[0]\n  const propertyName = propertyData[1]\n\n  return Object.keys(propertyValues).map((valueAbbreviation: string) => ({\n    $variations: [],\n    $content: [\n      options.addValueToSelector(\n        options.addPropertyToSelector('', propertyAbbreviation),\n        valueAbbreviation\n      ),\n      [[propertyName, propertyValues[valueAbbreviation]]]\n    ]\n  }))\n}\n\nconst parseVariable = (variable: string): [number, string] => {\n  const mod = '?+'.indexOf(variable[0]) + 1\n  const base = mod > 0 ? variable.slice(1) : variable\n  return [mod, base]\n}\n","// singleton embed pattern, using id as the unique identifier\nexport const embed = (css: string, id?: string): void => {\n  let styleEl: HTMLStyleElement | null = null\n  if (id !== undefined) styleEl = document.querySelector(`style#${id}`)\n\n  if (styleEl === null) {\n    styleEl = document.createElement('style')\n    styleEl.type = 'text/css'\n    if (id !== undefined) styleEl.setAttribute('id', id)\n    document.head.appendChild(styleEl)\n  }\n\n  styleEl.innerHTML = css\n}\n"],"names":[],"mappings":";;;;;;;;;UAKW;;;;;IAMT,IAAA,OAAO,IAAI,CAAA,OAAA,CAAJ,QAAA,kDAAA,CAAP;;;;;;wBC+BE;;;;;2EAmBK,uBAEP;;;gDAaI;;;;;;;;;;;;;;;;;;sCAuBoB,CAAC;;0BAMb;;iGAG8B;;;;;;;;;;;;;IAc1C,8BAAA,oBAAA;sDAC8C,CAAA,CAAA;kCACpB,kBACxB,iCAAA;;;;4BAGc;;qCAES;;;;;oDAIK,CAAC;oCACX,SAAS;;;;IAG1B;;gEAIG;;;;;;;;;IAkBP,6BAAA,kBAAA;kCAGC;IAKE,QAAI,+BAAA,IAAA,CAAJ;;;;;;;;;;;;;iBAUS;uBACE;;;;;;;;;;6BAYU;yBAKN,UACX,wCAA4B,QAAA,EAAA,KAAA,KAAA,IAAA,OAA5B;IACA;;;;;;;yCAQN,OAAO,SAAP,cAAA,GAEI,EAFJ,GAGI;;wBAKY,2BACR,4EACA,2BAFQ,QAAA,eAMd,8BAAA;;;QAAA,CANc;;;;;;;;;;sBAqCR,CAAC;;;eAGJ;;;;2BAYkC,MAAA,EAAQ,OAAR,WAAA;;;;;uBAkBtB,YAAoB;wBACrB;;mBAEL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC/Rb;UACa,KAAK,GAAG,CAAC,GAAD,IAAA;;YAEf,gBAAgB,+CAAA;;4BAEA;;;YAGlB;gBAAsB;;;;IAKzB;;;;;;;;;;;;;;;"}